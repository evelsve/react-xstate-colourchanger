{"version":3,"sources":["chartparser.js","dmAppointment.ts","dmTimer.ts","dmToDo.ts","runparser.js","grammars/orderGrammar.ts","dmSmartHome.ts","index.tsx","srgs.js"],"names":["LOG","str","clone","obj","temp","constructor","key","isEmpty","ob","i","hasOwnProperty","Chart","numberOfWords","this","passives","Array","actives","add","edge","subchart","cat","isPassive","start","lhs","end","next","content","resultsForRule","results","finalEdges","push","out","allEdges","allPassiveEdges","concat","allActiveEdges","edges","j","k","statistics","length","nrEdges","nrPassiveEdges","nrActiveEdges","PassiveEdge","_string","toString","ActiveEdge","rest","rules","text","parse","words","grammar","root","filter","$root","chart","agenda","leftCornerFilter","addToChart","inference","rhs","slice","SRGS","min","max","oneof","eval","undefined","ruleref","position","leftCorners","pop","active","join","ref","passive","person","day","time","approval","dmMachine1","initial","states","idle","who","on","RECOGNISED","cond","context","recResult","actions","assign","target","misUnderstood","prompt","entry","send","type","value","ENDSPEECH","ask","listen","nomatch","say","help","summary_time","summary_whole","created","Endings","num","dmMachine2","timer","option","WAIT","delay","annoy","other","dmMachine3","denial","loadGrammar","dom","DOMParser","parseFromString","ActiveXObject","doc","XML","newDocument","loadXML","url","encodeURIComponent","request","XMLHttpRequest","open","responseXML","parseXML","getElementsByTagName","getAttribute","xrules","r","xrule","processRuleExpansions","xitems","childNodes","rule","nodeType","textContent","trim","split","nodeName","uri","repeat","parseInt","Infinity","console","log","Order","input","gram","result","order","action","object","dmMachine4","welcome","task","promptAndAsk","perform","_context","saythis","on_help","misUnderstood2","on_end","inspect","iframe","snippet","machine","Machine","id","init","CLICK","query","invoke","src","_event","nluRequest","onDone","event","data","intent","name","onError","distributor","goodbye","dm1","dm2","dm3","dm4","asrtts","LISTEN","SPEAK","ttsAgenda","recognising","exit","ASRRESULT","progress","match","speaking","recLogResult","test","logIntent","nluData","ReactiveButton","props","state","matches","className","style","animation","App","useSpeechSynthesis","onEnd","speak","cancel","useSpeechRecognition","onResult","stop","listening","useMachine","devTools","recStart","asEffect","interimResults","continuous","recStop","ttsStart","effect","ttsCancel","current","onClick","fetch","Request","proxyurl","method","headers","body","then","json","rootElement","document","getElementById","ReactDOM","Grammar","VOID","OneOf","NULL","GARBAGE","$check","checkSequenceExpansion","err","throwRuleError","Ref","RefClass","Tag","tag","TagClass","alternatives","OneOfClass","Repeat","sequence","RepeatClass","message","error","TypeError","String","checkExpansion","prototype","Number"],"mappings":"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","file":"static/js/main.9cfae3b9.chunk.js","sourcesContent":["//\n//  chartparser.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/* Mods by Torbjörn\n- Removed the toString() method from Object. Why does it still work?\n- Added a text variable (similar to rules). See \n*/\n\n//////////////////////////////////////////////////////////////////////\n// a logging function\n//  - uncomment if you want to debug the parsing process\nfunction LOG(str) {\n  //console.log(\"\" + str);\n}\n\nimport * as SRGS from './srgs'\n\n//////////////////////////////////////////////////////////////////////\n// we need to be able to clone objects between different edges\n// borrowed from http://keithdevens.com/weblog/archive/2007/Jun/07/javascript.clone\nfunction clone(obj){\n  if (obj == null || typeof(obj) != 'object') {\n    return obj;\n  }\n  var temp = new obj.constructor(); \n  for (var key in obj) {\n    temp[key] = clone(obj[key]);\n  }\n  return temp;\n}\n\n\nfunction isEmpty(ob){\n   for (var i in ob) { if(ob.hasOwnProperty(i)) {return false;}}\n  return true;\n}\n\n//////////////////////////////////////////////////////////////////////\n// parse chart\n// conceptually this is a set of edges, but it is optimized\nfunction Chart(numberOfWords) {\n  this.numberOfWords = numberOfWords;\n  this.passives = new Array(numberOfWords);\n  this.actives = new Array(numberOfWords);\n  for (var i = 0; i <= numberOfWords; i++) {\n    this.passives[i] = {};\n    this.actives[i] = {};\n  }\n\n  // Chart.add(edge)\n  // add the edge to the chart, return true if the chart was changed \n  // (i.e. if the chart didn't already contain the edge)\n  this.add = function add(edge) {\n    var subchart, cat;\n    if (edge.isPassive) {\n      subchart = this.passives[edge.start];\n      cat = edge.lhs;\n    } else {\n      subchart = this.actives[edge.end];\n      cat = edge.next.content;\n    }\n    if (!(cat in subchart)) {\n      subchart[cat] = {};\n    }\n    if (edge in subchart[cat]) {\n      return false;\n    } else {\n      subchart[cat][edge] = edge;\n      return true;\n    }\n  }\n\n  // Chart.resultsForRule(lhs, start, end)\n  // return all parse results for the given lhs, start, and end\n  //  - start, end are optional; defaults to 0, numberOfWords\n  this.resultsForRule = function resultsForRule(lhs, start, end) {\n    start = start || 0;\n    end = end || numberOfWords;\n    var results = [];\n    var finalEdges = this.passives[start][lhs];\n    for (var i in finalEdges) {\n      if (finalEdges[i].end == end) {\n\tresults.push(finalEdges[i].out);\n      }\n    }\n    return results;\n  }\n  \n  // Chart.allEdges() / Chart.allPassiveEdges() / Chart.allActiveEdges()\n  // return an array of all (passive/active) edges in the chart\n  this.allEdges = function allEdges() {\n    return this.allPassiveEdges().concat(this.allActiveEdges());\n  }\n  this.allPassiveEdges = function allPassiveEdges() {\n    var edges = [];\n    for (var i in this.passives) \n      for (var j in this.passives[i]) \n\tfor (var k in this.passives[i][j])\n\t  edges.push(this.passives[i][j][k]);\n    return edges;\n  }\n  this.allActiveEdges = function allActiveEdges() {\n    var edges = [];\n    for (var i in this.actives) \n      for (var j in this.actives[i]) \n\tfor (var k in this.actives[i][j])\n\t  edges.push(this.actives[i][j][k]);\n    return edges;\n  }\n\n  // Chart.statistics()\n  // return the number of edges in the chart\n  this.statistics = function statistics() {\n    var passives = this.allPassiveEdges().length;\n    var actives = this.allActiveEdges().length;\n    return {nrEdges: passives+actives, nrPassiveEdges: passives, nrActiveEdges: actives};\n  }\n}\n\n\n//////////////////////////////////////////////////////////////////////\n// parse edges: passive and active\n\nfunction PassiveEdge(start, end, lhs, out) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.out = out;\n  this.isPassive = true;\n\n  var str = \"[\" + start + \"-\" + end + \"] $\" + lhs + \" := \" + out;\n  this._string = str;\n  this.toString = function toString() {return this._string;} \n}\n\nfunction ActiveEdge(start, end, lhs, next, rest, out, rules, text) {\n  this.start = start;\n  this.end = end;\n  this.lhs = lhs;\n  this.next = next;\n  this.rest = rest;\n  this.out = out;\n  this.rules = rules;\n  this.text = text;\n  this.isPassive = false;\n\n  var str = \"<\" + start + \"-\" + end + \"> $\" + lhs + \" -> \" + next + \n    \", \" + rest + \" := \" + out + \" <- \" + rules;\n  this._string = str;\n  this.toString = function toString() {return this._string;} \n}\n\n\n//////////////////////////////////////////////////////////////////////\n// the main parsing function: a simple top-down chartparser\n//  - 'words' is an array of strings\n//  - 'grammar' is a hash table of left-hand-sides mapping to arrays of right-hand-sides\n//  - 'root' is the starting category (a string)\n//    if unspecified, use the '$root' property of the grammar\n//  - 'filter' is an optional left-corner filter \n//    (a mapping from categories/rule-refs to words)\n//    if specified, it is used when predicting new edges\n// returns the final chart\nexport function parse(words, grammar, root, filter) {\n  if (!root) {\n    root = grammar.$root;\n  }\n  var chart = new Chart(words.length);\n  var agenda = [];\n\n  var leftCornerFilter;\n  if (filter == undefined) {\n    leftCornerFilter = function() {return true};\n  } else {\n    leftCornerFilter = function leftCornerFilter(ruleref, position) {\n      var leftCorners = filter[ruleref];\n      return leftCorners ? words[position] in leftCorners : true;\n    }\n  }\n  \n  // add an edge to the chart and the agenda, if it does not already exist\n  function addToChart(inference, start, end, lhs, rhs, out, rules, text) {\n    var edge;\n    if (rhs.length > 0) {\n      var next = rhs[0];\n      var rest = rhs.slice(1);\n      switch (next.constructor) {\n\t\n      case Array:\n\t// the next symbol is a sequence\n\taddToChart(inference+\",SEQUENCE\", start, end, lhs, next.concat(rest), out, rules, text);\n\treturn;\n\t\n      case SRGS.RepeatClass:\n\t// the next symbol is a repetition\n\tvar min = next.min;\n\tvar max = next.max;\n\t// skip repeat \n\tif (min <= 0) {\n\t  addToChart(inference+\",SKIP\", start, end, lhs, rest, out, rules, text);\n\t}\n\t// repeat \n\tif (max > 0) {\n\t  var content = next.content;\n\t  var rhs = (max==1 ? [content] : [content, SRGS.Repeat(min ? min-1 : min, max-1, content)]);\n\t  addToChart(inference+\",REPEAT\", start, end, lhs, rhs.concat(rest), out, rules, text);\n\t}\n\treturn;\n\t\n      case SRGS.OneOfClass:\n\t// the next symbol is a disjunction\n\tvar oneof = next.content;\n\tfor (var i in oneof) {\n\t  var rhs = oneof[i].concat(rest);\n\t  addToChart(inference+\",ONEOF\", start, end, lhs, rhs, out, rules, text);\n\t} \n\treturn;\n\t\n      case SRGS.TagClass:\n\t// the next symbol is a semantic action\n\tout = clone(out);\n\trules = clone(rules);\n\teval(next.content);\n\taddToChart(inference+\",TAG\", start, end, lhs, rest, out, rules, text);\n\treturn;\n      }\n\n      edge = new ActiveEdge(start, end, lhs, next, rest, out, rules, text);\n    } else {\n      edge = new PassiveEdge(start, end, lhs, out);\n    }\n    \n    // try to add the edge; if successful, also add it to the agenda\n    if (chart.add(edge)) {\n      LOG(\"+ \" + inference + \": \" + edge);\n      agenda.push(edge);\n    }\n  }\n  \n  // seed the agenda with the starting rule\n  addToChart(\"INIT\", 0, 0, root, grammar[root], {}, {}, {});\n  \n  // main loop\n  while (agenda.length > 0) {\n    var edge = agenda.pop();\n    var start= edge.start;\n    var end  = edge.end;\n    var lhs  = edge.lhs;\n    var next = edge.next;\n    LOG(edge);\n\n    if (edge.isPassive) {\n      // combine\n      var actives = chart.actives[start][lhs];\n      for (var i in actives) {\n\tvar active = actives[i];\n\tvar rules = clone(active.rules);\n\tvar text = active.text;\n\ttext[edge.lhs] = words.slice(start, end).join(\" \");\n\tif (typeof edge.out == 'object' && isEmpty(edge.out)) {\n\t    rules[edge.lhs] = text[edge.lhs];\n\t} else {\n        rules[edge.lhs] = clone(edge.out);\n    }\n\taddToChart(\"COMBINE\", active.start, end, active.lhs, active.rest, active.out, rules, text);\n      }\n\n    } else if (next.constructor == SRGS.RefClass) {\n      var ref = next.content;\n      // combine\n      var passives = chart.passives[end][ref];\n      for (var i in passives) {\n\tvar passive = passives[i];\n\tvar rules = clone(edge.rules);\n\tvar text = edge.text;\n\trules[passive.lhs] = clone(passive.out);\n\ttext[passive.lhs] = passive.text;\n\taddToChart(\"COMBINE\", start, passive.end, lhs, edge.rest, edge.out, rules, text);\n      }\n      // predict\n      if (ref in grammar) {\n\tif (leftCornerFilter(ref, end)) {\n\t  addToChart(\"PREDICT\", end, end, ref, grammar[ref], {}, {}, {});\n\t}\n      }\n\n    } else if (next == words[end]) {\n      // scan\n      addToChart(\"SCAN\", start, end+1, lhs, edge.rest, edge.out, edge.rules, edge.text);\n    }\n  }\n\n  return chart;\n}\n\n\n","import { MachineConfig, send, assign } from \"xstate\";\nimport {say, listen, Endings, misUnderstood} from \"./index\";\n// import { SimulatedClock } from 'xstate/lib/SimulatedClock'; // >= 4.6.0\n\n\n// GRAMMAR\n\nconst grammar: { [index: string]: {\n        appointment?: string,\n        to_do?: string,\n        timer?: string,\n        person?: string,\n        day?: string,\n        time?: string,\n        approval?:  boolean,\n    }} =  {\n            // ___________________________________________\n            \"hairdresser\": { person: \"hairdresser\" },\n            \"doctor\": { person: \"doctor\" },\n            \"dentist\": { person: \"dentist\" },\n            \"lawyer\": { person: \"lawyer\" },\n            \"psychotherapist\": { person: \"psychotherapist\" },\n            \"John\": { person: \"John Appleseed\" },\n            \"Peter\": { person: \"Peter Horter\" },\n            \"Jack\": { person: \"Jack Tomerson\" },\n            \"Tom\": { person: \"Tom Peterson\" },\n            \"Jill\": { person: \"Jill Panele\" },\n            \"Jane\": { person: \"Jane Mayer\" },\n            \"Anna\": { person: \"Anna Pana\" },\n            \"Lora\": { person: \"Lora Cat\" },\n            // ___________________________________________\n            \"on Monday\": { day: \"Monday\" },\n            \"on Tuesday\": { day: \"Tuesday\" },\n            \"on Wednesday\": { day: \"Wednesday\" },\n            \"on Thursday\": { day: \"Thursday\" },\n            \"on Friday\": { day: \"Friday\" },\n            \"on Saturday\": { day: \"Saturday\" },\n            \"on Sunday\": { day: \"Sunday\" },\n            \"on Monday next week\": { day: \"Monday next week\" },\n            \"on Tuesday next week\": { day: \"Tuesday next week\" },\n            \"on Wednesday next week\": { day: \"Wednesday next week\" },\n            \"on Thursday next week\": { day: \"Thursday next week\" },\n            \"on Friday next week\": { day: \"Friday next week\" },\n            \"on Saturday next week\": { day: \"Saturday next week\" },\n            \"on Sunday next week\": { day: \"Sunday next week\" },\n            // ___________________________________________\n            \"8\": { time: \"eight\" },\n            \"9\": { time: \"nine\" },\n            \"10\": { time: \"ten\" },\n            \"11\": { time: \"eleven\" },\n            \"at noon\": { time: \"twelve\" },\n            \"12\": { time: \"twelve\" },\n            \"1\": { time: \"thirteen\" },\n            \"2\": { time: \"fourteen\" },\n            \"3\": { time: \"fifteen\" },\n            \"4\": { time: \"sixteen\" },\n            \"5\": { time: \"seventeen\" },\n            \"6\": { time: \"six\" },\n            \"7\": { time: \"seven\" },\n            \"8 15\": { time: \"eight fifteen\" },\n            \"9 15\": { time: \"nine fifteen\" },\n            \"10 15\": { time: \"ten fifteen\" },\n            \"11 15\": { time: \"eleven fifteen\" },\n            \"12 15\": { time: \"twelve fifteen\" },\n            \"1 15\": { time: \"one fifteen\" },\n            \"2 15\": { time: \"two fifteen\" },\n            \"3 15\": { time: \"three fifteen\" },\n            \"4 15\": { time: \"four fifteen\" },\n            \"5 15\": { time: \"five fifteen\" },\n            \"6 15\": { time: \"six fifteen\" },\n            \"7 15\": { time: \"seven fifteen\" },\n            \"8 30\": { time: \"half past eight\" },\n            \"9 30\": { time: \"half past nine\" },\n            \"10 30\": { time: \"half past ten\" },\n            \"11 30\": { time: \"half past eleven\" },\n            \"half past twelve\": { time: \"half past twelve\" },\n            \"12 30 \": { time: \"half past twlve\" },\n            \"1 30\": { time: \"half past one\" },\n            \"2 30\": { time: \"half past two\" },\n            \"3 30\": { time: \"half past three\" },\n            \"4 30\": { time: \"half past four\" },\n            \"5 30\": { time: \"half past five\" },\n            \"6 30\": { time: \"half past six\" },\n            \"7 30\": { time: \"half past seven\" },\n            // ___________________________________________\n            \"of course\": { approval: true },\n            \"yes\": { approval: true },\n            \"yeah\": { approval: true },\n            \"yup\": { approval: true },\n            \"sure\": { approval: true },\n            \"no\": { approval: false },\n            \"nah\": { approval: false },\n            \"nope\": { approval: false }}\n\n            \n\n\nexport const dmMachine1: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'idle',\n    states: {\n        // ...\n        idle: {},\n        // ...\n        who: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                    {cond: (context) => \"person\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { person: grammar[context.recResult].person } }),\n                    target: \"day\"},\n\n                    {cond: (context) => context.recResult === \"help\"},\n\n                    { target: \".nomatch\" }],\n            },\n            ...misUnderstood(`Who are you meeting with?`,  [\"#root.dm1.idle\", \"#root.init.help\"])\n        },\n        // ...\n        day: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                    {cond: (context) => \"day\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { day: grammar[context.recResult].day } }),\n                    target: \"approval\" },\n\n                    {cond: (context) => context.recResult === \"help\", target: \".help\" },\n\n                    { target: \".nomatch\" } ]\n                \n                },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `OK. ${context.person} it is. On which day is your meeting?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry, I do not understand\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                },\n                help: {\n                    entry: say(\"We may be miscommunicating. Let's take a step back\"),\n                    on: { ENDSPEECH: \"#root.dm1.who\" }\n                }\n            },\n            // ...misUnderstood(`OK. ${context.person} it is. On which day is your meeting?`, \"#root.dm1.who\", ''),\n            // Note: still can't understand why misUnderstood2 function does not work on prompts with context.\n        },\n        // ...\n        approval: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                    {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === true,\n                    actions: assign((context) => { return { approval: true } }),\n                    target: \"summary_whole\"},\n\n                    {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === false,\n                    actions: assign((context) => { return { approval: false} }),\n                    target: \"time\"},\n\n                    {cond: (context) => context.recResult === \"help\", target: \".help\" },\n\n                    { target: \".nomatch\" }\n                ]\n                },\n                // ...misUnderstood(`Ok, meeting on ${context.day}. Will it take the whole day?`, \"#root.dm1.day\")},\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Ok, meeting on ${context.day}. Will it take the whole day?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()   \n                },\n                nomatch: {\n                    entry: say(\"Sorry, I do not understand\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                },\n                help: {\n                    entry: say(\"We may be miscommunicating. Let's take a step back\"),\n                    on: { ENDSPEECH: \"#root.dm1.day\" }\n                }\n            }\n        },\n        // ...\n        time: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                    {cond: (context) => \"time\" in (grammar[context.recResult] || {}),\n                    actions: assign((context) => { return { time: grammar[context.recResult].time } }),\n                    target: \"summary_time\"},\n\n                    {cond: (context) => context.recResult === \"help\",\n                    target: \".help\" },\n\n                    { target: \".nomatch\" }]\n            },\n        ...misUnderstood(`What time is your meeting?`, \"#root.dm1.approval\")},\n        // ...\n        summary_time: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                    {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === true,\n                    actions: assign((context) => { return { approval: true } }),\n                    target: \"created\"},\n\n                    {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === false,\n                    actions: assign((context) => { return { approval: false } }),\n                    target: \"who\"},\n\n                    {cond: (context) => context.recResult === \"help\",\n                    target: \".help\" },\n\n                    { target: \".nomatch\" }]\n                },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Do you want me to create an appointment with ${context.person} on ${context.day} at ${context.time}?`\n                    })),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry, I do not understand\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                },\n                help: {\n                    entry: say(\"We may be miscommunicating. Let's take a step back\"),\n                    on: { ENDSPEECH: \"#root.dm1.approval\" }\n                }\n            }\n        },\n        // ...\n        summary_whole: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                    {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === true,\n                    actions: assign((context) => { return { approval: true } }),\n                    target: \"created\"},\n\n                    {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === false,\n                    actions: assign((context) => { return { approval: false } }),\n                    target: \"who\"},\n\n                    {cond: (context) => context.recResult === \"help\",\n                    target: \".help\" },\n\n                    { target: \".nomatch\" }]\n                },\n            states: {\n                prompt: {\n                    entry: send((context) => ({\n                        type: \"SPEAK\",\n                        value: `Do you want me to create an appointment with ${context.person} on ${context.day} for the whole day?`})),\n                    on: { ENDSPEECH: \"ask\" }\n                },\n                ask: {\n                    entry: listen()\n                },\n                nomatch: {\n                    entry: say(\"Sorry, I do not understand\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                },\n                help: {\n                    entry: say(\"We may be miscommunicating. Let's take a step back\"),\n                    on: { ENDSPEECH: \"#root.dm1.approval\" }\n                }\n            }    \n        },\n        created: {...Endings(\"Your appoinment has been created\",\"#root.init.goodbye\"), \n        // always: \"idle\"\n        }\n    }\n})\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n// ONLY DRAFTS\n\n\n\n\n// done: {...Endings(\"Congratulations on your accomplishment!\",\"#root.init\")},\n\n          // annoy:{\n            //     initial: \"prompt\",\n            //     on: {\n            //         RECOGNISED: [\n            //             {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === true,\n            //             target: \"done\"},\n\n            //             {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === false,\n            //             target: \".wait\"}],\n                    \n            //         // WAIT: '.wait'\n\n            //         }\n            //     },\n\n             // ...\n            // annoy: {\n            //     initial: \"prompt\",\n            //     on: {\n            //         RECOGNISED: [\n            //             {cond: (context) => context.option === 'agrreement', target: \"done\"},\n\n            //             {cond: (context) => context.option === 'disagreement', target: \".wait\"},\n                        \n            //             {target: \".wait\"}], \n\n            //         WAIT: '.prompt'\n            //     },\n            //     states: {\n            //         prompt: {\n            //             entry: say(\"Have you done your task yet?\"),\n            //             on: { ENDSPEECH: \"ask\" }\n            //         },\n            //         ask: {\n            //             entry: [ send('LISTEN'), send('WAIT', {delay: 5000})]\n            //         },\n            //         // wait2: {entry: [ send('WAIT', {delay: 3000})]},\n            //         wait: {\n            //             entry: [\n            //                 say('Hm.')\n            //             ],\n            //             on: {\n            //                 ENDSPEECH: [\n            //                     {cond: () => (num++) <= 2, target: 'prompt'},\n            //                     {target: '#root.dm1.done'}\n            //                 ]\n            //             }\n            //         }\n            //     }\n            // },\n\n\n            // ----\n\n            // quest1: {\n                //     on: {\n                //         RECOGNISED: [\n                //                 {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === true,\n                //                 actions: assign((context) => { return { approval: true } }),\n                //                 target: \"#root.dm1.create_do\"},\n            \n                //                 {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === false,\n                //                 actions: assign((context) => { return { approval: false} }),\n                //                 target: \"#root.dm1.if_ideas\"},\n\n                //                 {target: \"#root.dm1.done.others\"}\n\n                //                 // {cond: (context) => context.option === 'help', target: '.help'}\n                //                 ]\n                //         },\n                //         ...promptHelpBye(\"I suppose you could do something productive. Do you agree?\")\n                //         },\\\n\n\n\n                // ------\n\n                // done: {\n                //     initial: \"prompt\",\n                //     // on: {ENDSPEECH: ['#root.dm1.idle']},\n                //         states: {\n                //             prompt: {\n                //                 entry: say(\"Congratulations on your accomplishment! Here's a reward\"),\n                //                 on: { ENDSPEECH: ['#root.dm1.idle', '#root.init.help.goodbye']}\n                //         }, \n                //             others: {\n                //                 entry: say(\"Ummm, you said something strange\"),\n                //                 on: { ENDSPEECH: '#root.dm1.positive.quest2'}\n                //                 }\n                //         }\n                //     }   \n\n\n                // ------\n\n\n                // idea: {\n                //     initial: \"prompt\",\n                //     // on: {ENDSPEECH: ['#root.dm1.idle']},\n                //         states: {\n                //             prompt: {\n                //                 entry: send((context) => ({\n                //                     type: \"SPEAK\",\n                //                     value:`You should work on your idea of ${context.idea}. Say 'finished', when you're done` })),\n                //                 on: { ENDSPEECH: ['#root.dm1.idea_wait']}\n                //             // },\n                //     //         elevator: {\n                //     //             entry: send(openInNewTab('https://www.youtube.com/watch?v=VBlFHuCzPgY&t=3s&ab_channel=AntoineB')),\n                //     //             on: { ENDSPEECH: '#root.dm1.idea_wait'}\n                //                 }\n                //     }\n                // }\n\n                // ------\n\n            // annoy: {\n            //     initial: \"prompt\",\n            //     on: {\n            //         RECOGNISED: {\n            //             target: \"conditional3\",\n            //             actions: assign((context) => { return { option: context.recResult } }),\n            //         },\n            //         WAIT: 'wait'\n            //     },\n            //     states: {\n            //         prompt: {\n            //             entry: say(\"Let me know when you're done.\"),\n            //             on: { ENDSPEECH: \"ask\" }\n            //         },\n            //         ask: {\n            //             entry: [\n            //                 send('LISTEN'),\n            //                 send('WAIT', {delay: 10000})\n            //             ]\n            //         }\n            //     }\n            // },\n            // ...\n            // wait: {\n                \n            //     entry: [say('Have you done your task yet?')],\n            //     on: {\n            //         ENDSPEECH: [\n            //             {cond: () => (num++, 1) <= 5, target: 'conditional3'},\n            //             {target: '#root.dm1.idea_wait'}\n            //         ]\n            //     }\n            // },\n            // conditional3: {...Conditional('agreement', \"#root.dm1.done\", 'disagreement', \"#root.dm1.annoy\", \"#root.dm1.annoy\", '#root.dm1.idle', `Mhm.`)},\n\n\n            // -----\n\n                // ...\n                // full_annoy:{\n                //     initial: 'annoy',\n                //     on: { \n                //         // RECOGNISED: {\n                //         //         cond: (context) => help_commands.includes(context.recResult),\n                //         //         target: '#root.init.help'\n                //         //             },\n    \n                //         MAXSPEECH: [\n                //             { \n                //                 cond: (context) => context.count < 5,\n                //                 target: '#root.dm1.idea_wait'},\n    \n                //                 {cond: (context) => context.count == null,\n                //                 actions: assign((context)=>{return {count: Number(0)}}),\n                //                 target: '#root.dm1.maxspeech'}],\n                //             },\n                //     states:{\n                //         hist:{type: 'history'},\n                //         // .... // ...\n                //         annoy: {\n                //             on: {\n                //                 RECOGNISED: [{\n                //                     cond: (context) => \"finished\" in (gram[context.recResult] || {}),\n                //                     actions: assign((context) => { return { finished: gram[context.recResult].finished } }),\n                //                     target: \"#root.dm1.done\"}]\n        \n                //                 // },\n                //                 // { cond: (context) => !(help_commands.includes(context.recResult)),\n                //                 //     target: \".nomatch\" }]\n                //             },\n                //             ...Prompt_Nomatch_Timeout('Have you done your task yet?', \"Sorry I don't understand\"),\n                //         }\n                // },\n                // // ....\n                // },\n                // // ... \n                // maxspeech:{\n                //     initial: 'prompt',\n                //     on: {\n                //         ENDSPEECH: {\n                //             actions: assign((context)=> {return {count: context.count+1 }}),\n                //             target: 'full_annoy.hist'\n                //                 }\n                //             },\n                //             // target: 'fill_appointment_info.hist'\n                //         states: {\n                //             prompt: {entry: say('I AM A STUPID BOT ')}\n                //     }\n                // },\n\n                // ...\n\n                            // ..\n        //     wait: {\n        //         initial: 'prompt',\n        //         on: { ENDSPEECH: '#root.dm1.annoy'},\n        //         states: {\n        //             prompt: {\n        //                 entry: say(\"M.\"),\n        //                 // on: { ENDSPEECH: \"#root.dm1.annoy\" }\n        //             },\n        //             // ask: {\n        //             //     entry: [\n        //             //         send('LISTEN'),\n        //             //         send('WAIT', {delay: 10000})\n        //             //     ]}\n        //             }\n        // },\n        //     // ...\n        //     annoy: {\n        //         initial: \"prompt\",\n        //         on: {\n        //             RECOGNISED: {\n        //                 target: \"conditional3\",\n        //                 actions: assign((context) => { return { option: context.recResult } }),\n        //             },\n        //             WAIT: 'wait'\n        //         },\n        //         states: {\n        //             prompt: {\n        //                 entry: say(\"Have you finished your task?\"),\n        //                 on: { ENDSPEECH: \"ask\" }\n        //             },\n        //             ask: {\n        //                 entry: [\n        //                     send('LISTEN'),\n        //                     send('WAIT', {delay: 10000})\n        //                 ]\n        //             }\n        //         }\n        //     },\n            // conditional3: {...Conditional('agreement', \"#root.dm1.done\", 'disagreement', \"#root.dm1.wait\", \"#root.dm1.annoy\", '#root.dm1.idle', `Oh`)},\n","import { MachineConfig, send, assign } from \"xstate\";\nimport { say } from \"./index\";\n\n\nlet num = 0\n\nexport const dmMachine2: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: \"idle\",\n        states: {\n            idle: {},\n            timer: {\n                initial: \"prompt\",\n                on: {\n                    RECOGNISED: {\n                        target: \"other\",\n                        actions: assign((context) => { return { option: context.recResult } }),\n                    },\n                    WAIT: {target: \"annoy\",\n                          actions: assign(() => num++),\n                        //    actions: send('SPEAK')\n                        }\n                },\n                states: {\n                    prompt: {\n                        entry: say(\"Say something.\"), \n                        // action: assign(() => num === 0)\n                        on: { ENDSPEECH: \"ask\" }\n                    },\n                    ask: {\n                        entry: [\n                            send('LISTEN'),\n                            send('WAIT', {delay: 2000})\n                        ]\n                    }}},\n                    // ...\n                    annoy: {\n                        entry: say('No input. Try again'),\n                        on: {\n                            ENDSPEECH: [\n                                {cond: () => num === 0, target: '#root.dm2.timer'},\n                                {cond: () => num === 1, target: '#root.dm2.timer'},\n                                {cond: () => num === 2, target: '#root.dm2.timer'},\n                                {target: '#root.dm2.other'}\n                            ]},\n                        \n                    },\n                    // ...\n                    other: {\n                        entry: say(\"Understood. Try silent\"),\n                        on: { ENDSPEECH: \"#root.dm2.idle\" }\n                    }      \n            // prompt: {\n            //     on: { \n            //         ENDSPEECH: 'wait1',\n            //         WAIT: 'wait2'\n            // }},\n            // wait1: {\n            //     on: {ENDSPEECH: 'p'},\n            //     entry: say(\"Question\")\n            // },\n            // wait2: {\n            //     on: {ENDSPEECH: 'wait2'},\n            //     entry: say(\"No input\")\n            // },\n}})\n\n","import { MachineConfig } from \"xstate\";\nimport { Endings } from \"./index\";\n\nexport const dmMachine3: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'idle',\n    states: {\n        idle: {},\n        denial: {...Endings(\"Welcome to To-do. It will be improved later.\",\"#root.dm3.idle\")},\n}})\n","//\n//  runparser.js\n//\n/*\n  The author or authors of this code dedicate any and all \n  copyright interest in this code to the public domain.\n*/\n\n\n// helper functions for the parser demo\n\nimport * as SRGS from './srgs'\n\nfunction getElement(id) {\n  return document.getElementById(id);\n}\n\nfunction appendElement(parent, element, text) {\n  var elem = document.createElement(element);\n  if (text)\n    elem.appendChild(document.createTextNode(text));\n  parent.appendChild(elem);\n  return elem\n}\n\nfunction runParser(input) {\n  var resultsDiv = getElement(\"results\");\n  resultsDiv.innerHTML = \"\";\n  var maybeFilter;\n  if (getElement(\"usefilter\") && getElement(\"usefilter\").checked) {\n    maybeFilter = filter;\n    appendElement(resultsDiv, \"EM\", \"Using left-corner filter\");\n  }\n  var startTime = new Date();\n  var parseChart = parse(input, grammar, grammar.$root, maybeFilter);\n  var parseTime = new Date() - startTime;\n  var parseResults = parseChart.resultsForRule(grammar.$root);\n  \n  console.log(parseResults[0]);\n  \n  if (parseResults) {\n    for (var i in parseResults) {\n        resultsDiv.innerHTML += display(parseResults[i],\"\");\n    }\n  } else {\n    appendElement(resultsDiv, \"P\", \"No results found!\");\n  }\n  \n/*\n  if (parseResults) { \n    var resultList = appendElement(resultsDiv, \"OL\");\n    for (var i in parseResults) \n      appendElement(resultList, \"LI\", JSON.stringify(parseResults[i]));\n  } else {\n    appendElement(resultsDiv, \"P\", \"No results found!\");\n  }\n*/\n  var statistics = parseChart.statistics()\n  appendElement(resultsDiv, \"P\", \"Chart size: \" + statistics.nrEdges + \" edges\" +\n\t\t\" (\" + statistics.nrPassiveEdges + \" passive)\");\n  appendElement(resultsDiv, \"P\", \"Parse time: \" + parseTime + \" ms\" + \n\t\t\" (\" + (parseTime / statistics.nrEdges).toFixed(2) + \" ms/edge)\");\n}\n\nfunction runWordParser() {\n  runParser(getElement(\"input\").value.split(/\\s+/));\n}\n\nfunction runCharacterParser() {\n  runParser(getElement(\"input\").value.split(\"\"));\n}\n\nexport function loadGrammar(str) {\n    var dom = parseXML(str);\n    var root = dom.getElementsByTagName(\"grammar\")[0].getAttribute(\"root\");\n    var grammar = new SRGS.Grammar(root);\n    var xrules = dom.getElementsByTagName(\"rule\");\n    for(var r=0; r < xrules.length; r++) {\n        var xrule = xrules[r];\n        var id = xrule.getAttribute(\"id\");\n        grammar[id] = processRuleExpansions(xrule);\n    }\n    return grammar;\n}\n\nfunction processRuleExpansions(xrule) {\n    var xitems = xrule.childNodes;\n    var rule = [];\n    for(var i=0; i < xitems.length; i++) {\n        if (xitems[i].nodeType == 3) {\n            var str = xitems[i].textContent.trim();\n            if (str != \"\") {\n                rule.push(str.split(/ +/));\n            }\n        } else if (xitems[i].nodeType == 1) {\n            if (xitems[i].nodeName == \"token\") {\n                rule.push(SRGS.Tag(xitems[i].textContent));\n            } else if (xitems[i].nodeName == \"ruleref\") {\n                var uri = xitems[i].getAttribute(\"uri\");\n                rule.push(SRGS.Ref(uri.slice(1)));\n            } else if (xitems[i].nodeName == \"tag\") {\n                rule.push(SRGS.Tag(xitems[i].textContent.trim()));\n            } else if (xitems[i].nodeName == \"one-of\") {\n                rule.push(SRGS.OneOf(processRuleExpansions(xitems[i])));\n            } else if (xitems[i].nodeName == \"item\") {\n                var repeat = xitems[i].getAttribute(\"repeat\");\n                if (!repeat) {\n                    rule.push(processRuleExpansions(xitems[i]));\n                } else {\n                    var r = repeat.split(\"-\");\n                    var min = parseInt(r[0]);\n                    var max = parseInt(r[1]);\n                    max = (max) ? max : Infinity;\n                    rule.push(SRGS.Repeat(min, max, processRuleExpansions(xitems[i])));\n                }\n            } else {\n                console.log(xitems[i]);\n            }\n        }\n    }\n\treturn rule;\n}\n\nfunction parseXML(text) {\n    if (typeof DOMParser != \"undefined\") {\n        // Mozilla, Firefox, and related browsers\n        return (new DOMParser()).parseFromString(text, \"application/xml\");\n    }\n    else if (typeof ActiveXObject != \"undefined\") {\n        // Internet Explorer.\n        var doc = XML.newDocument();  // Create an empty document\n        doc.loadXML(text);            // Parse text into it\n        return doc;                   // Return it\n    }\n    else {\n        // As a last resort, try loading the document from a data: URL\n        // This is supposed to work in Safari. Thanks to Manos Batsis and\n        // his Sarissa library (sarissa.sourceforge.net) for this technique.\n        var url = \"data:text/xml;charset=utf-8,\" + encodeURIComponent(text);\n        var request = new XMLHttpRequest();\n        request.open(\"GET\", url, false);\n        request.send(null);\n        return request.responseXML;\n    }\n};\n","export const grammar = `\n<grammar root=\"smarthome\">\n    <rule id=\"smarthome\">\n\n        <ruleref uri=\"#order\"/>\n            <tag>out.order= new Object(); out.order.object=rules.order.entity; out.order.action=rules.order.event;</tag>\n        </rule>\n\n    <item repeat=\"0-\">please</item>\n\n    <rule id=\"verb\">\n        <one-of>\n            <item>open<tag>out='open';</tag></item>\n            <item>close<tag>out='close';</tag></item>\n        </one-of>\n        </rule>\n\n    <rule id=\"on_off\">\n            <one-of>\n                <item></item>\n                <item>turn on</item>\n                <item>turn off</item>\n                <item>turn up</item>\n                <item>turn down</item>\n            </one-of>\n        </rule>\n\n    <rule id=\"appliance\">\n        the\n        <one-of>\n            <item>light<tag>out='light';</tag></item>\n            <item>AC<tag>out='air conditioning';</tag></item>\n            <item>A C<tag>out='air conditioning';</tag></item>\n            <item>air conditioning</item>\n            <item>heat<tag> out='heat';</tag></item>\n        </one-of>\n        </rule>\n\n    <rule id=\"opening\">\n        the\n        <one-of>\n            <item>door</item>\n            <item>window</item>\n        </one-of>\n        </rule>\n    \n <rule id=\"order\">\n\n  <one-of>\n   \n      <item>\n      <ruleref uri=\"#on_off\"/>\n      <ruleref uri=\"#appliance\"/>\n        <tag> out.event=rules.on_off; out.entity=rules.appliance;</tag>\n      </item>\n\n      <item>\n      <ruleref uri=\"#verb\"/>\n      <ruleref uri=\"#opening\"/>\n        <tag> out.event=rules.verb; out.entity=rules.opening;</tag>\n      </item>\n\n  </one-of>\n</rule>\n</grammar>\n`","import { MachineConfig, send, assign } from \"xstate\";\nimport {say, promptAndAsk } from \"./index\";\nimport { loadGrammar } from './runparser'\nimport { parse } from './chartparser'\nimport { grammar } from './grammars/orderGrammar'\n\n\nconst Order = (input: string) => {\n    const gram = loadGrammar(grammar);\n    const prs = parse(input.split(/\\s+/), gram);\n    const result = prs.resultsForRule(gram.$root)[0]\n    const answer = result.order.action + result.order.object;\n    return answer\n}\n\nexport const dmMachine4: MachineConfig<SDSContext, any, SDSEvent> = ({\n    initial: 'idle',\n    states: {\n        idle: {},\n        welcome: {\n            initial: \"prompt\",\n            on: { ENDSPEECH: \"task\" },\n            states: {\n                prompt: { entry: say(\"Welcome to Smart Home\") }\n            }\n        },\n        task: {\n            initial: \"prompt\",\n            on: {\n                RECOGNISED: [\n                    {cond: (context) => {return { order: Order(context.recResult) } !== undefined},\n                    actions: assign((context) => {return { order: Order(context.recResult) }}),\n                    target: 'perform'},\n\n                    { target: \"perform.nomatch\" }]\n                },\n            ...promptAndAsk(\"I await for your orders.\")\n        },\n        perform: {\n            initial: \"prompt\",\n            states: {\n                prompt: \n                    { entry: send((context) => ({type: \"SPEAK\", value: `The task ${context.order} has been accomplished`}))},\n                nomatch: {\n                    entry: say(\"Sorry, I do not understand\"),\n                    on: { ENDSPEECH: \"prompt\" }\n                }\n            }\n        }\n    }\n})","import \"./styles.scss\";\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { MachineConfig, Machine, send, Action, assign, State } from \"xstate\";\nimport { useMachine, asEffect } from \"@xstate/react\";\nimport { useSpeechSynthesis, useSpeechRecognition } from 'react-speech-kit';\nimport { inspect } from \"@xstate/inspect\";\n// Welcome to the machines\nimport { dmMachine1 } from \"./dmAppointment\";\nimport { dmMachine2 } from \"./dmTimer\";\nimport { dmMachine3 } from \"./dmToDo\";\nimport { dmMachine4 } from \"./dmSmartHome\";\n\n\ninspect({\n    url: \"https://statecharts.io/inspect\",\n    iframe: false\n});\n\n\nexport function say(text: string): Action<SDSContext, SDSEvent> {\n    return send((_context: SDSContext) => ({ type: \"SPEAK\", value: text }))\n}\n\nexport function listen(): Action<SDSContext, SDSEvent> {\n    return send('LISTEN')\n}\n\n\nexport function promptAndAsk(prompt: string): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n            prompt: {\n                entry: say(prompt),\n                on: { ENDSPEECH: 'ask' }\n            },\n            ask: {entry: send('LISTEN')}}\n    })\n}\n\nexport function misUnderstood(saythis: any, on_help: any): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n        prompt: {\n            entry: say(saythis),\n            on: { ENDSPEECH: \"ask\" }\n        },\n        ask: { \n            entry: listen()\n        },\n        nomatch: {\n            entry: say(\"Sorry, I do not understand.\"),\n            on: { ENDSPEECH: \"prompt\" }\n        },\n        help: {\n            entry: say(\"We may be miscommunicating. Let's take a step back\"),\n            on: { ENDSPEECH: on_help }\n        }\n}})}\n\n\nexport function misUnderstood2(saythis: any, on_help: any, _context: any): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({\n        initial: 'prompt',\n        states: {\n        prompt: {\n            entry: send((_context) => ({type: \"SPEAK\", value: saythis})),\n            on: { ENDSPEECH: \"ask\" }\n        },\n        ask: { \n            entry: listen()\n        },\n        nomatch: {\n            entry: say(\"Sorry, I do not understand.\"),\n            on: { ENDSPEECH: \"prompt\" }\n        },\n        help: {\n            entry: say(\"We may be miscommunicating. Let's take a step back\"),\n            on: { ENDSPEECH: on_help }\n        }\n}})}\n\nexport function Endings(saythis: string, on_end:string): MachineConfig<SDSContext, any, SDSEvent> {\n    return ({        \n        initial: \"prompt\",\n        states: {\n            idle: {},\n            prompt: {\n                entry: say(saythis),\n                on: { ENDSPEECH: on_end }}\n            }    \n        })}\n\nconst saySnippet: Action<SDSContext, SDSEvent> = send((context: SDSContext) => ({\n    type: \"SPEAK\", value: `${context.snippet}`\n}))\n\n//  GRAMMAR\n\nconst grammar: { [index: string]: {approval?:  boolean } } = \n{  \"of course\": { approval: true },\n    \"yes\": { approval: true },\n    \"yeah\": { approval: true },\n    \"yup\": { approval: true },\n    \"sure\": { approval: true },\n    \"no\": { approval: false },\n    \"nah\": { approval: false },\n    \"nope\": { approval: false }}\n\n\n\n//  MAIN MACHINE\n\nconst machine = Machine<SDSContext, any, SDSEvent>({\n    id: 'root',\n    type: 'parallel',\n    states: {\n        // ____________\n        init: {\n            initial: 'idle',\n            states: {\n                // ...\n                idle: {on: {CLICK: 'welcome'}},\n                // ...\n                welcome: {\n                    on: {\n                        RECOGNISED: {\n                            target: \"query\",\n                            actions: assign((context) => { return { option: context.recResult } }),\n                        }},\n                    ...promptAndAsk(\"What do you want to do?\")\n                },\n                // ...\n                query: {\n                    invoke: {\n                        id: 'rasa',\n                        src: (context, _event) => nluRequest(context.option),\n                        onDone: {\n                            actions: [assign((_context, event) => { return  {option: event.data.intent.name} }), \n                            (_context: SDSContext, event: any) => console.log(event.data)],\n                            target: \"distributor\"\n                        },\n                        onError: {\n                            target: 'welcome',\n                            actions: (_context, event) => console.log(event.data)}\n                    }\n                },\n                // ...\n                distributor: {\n                    initial: \"prompt\",\n                    on: {\n                        ENDSPEECH: [\n                            {cond: (context) => context.option === 'todo_on'|| context.option === 'todo_off', target: [\"#root.dm3.denial\", \"idle\"] },\n                            {cond: (context) => context.option === 'timer_on' || context.option === 'timer_off', target: [\"#root.dm2.timer\", \"idle\"] },\n                            {cond: (context) => context.option === 'appointment_on', target: [\"#root.dm1.who\", \"idle\"]},\n                            {cond: (context) => context.option === 'smart_on', target: [\"#root.dm4.welcome\", \"idle\"]},\n                            {cond: (context) => context.option === 'help_on', target: \"help\"},\n                            {cond: (context) => context.option === 'appointment_off', target: \"other\"}]\n                        },\n                    states: {\n                        prompt: {\n                            entry: send((_context) => ({type: \"SPEAK\", value: `Understood.`})),\n                        }\n                    }\n                },\n                // ...\n                help: {\n                    on: {\n                        RECOGNISED: [\n                            {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === true,\n                            actions: assign((_context) => { return { approval: true } }),\n                            target: \"welcome\"},\n\n                            {cond: (context) => grammar[context.recResult] !== undefined && grammar[context.recResult].approval === false,\n                            actions: assign((_context) => { return { approval: false} }),\n                            target: \"goodbye\"},]  \n                    },\n                ...promptAndAsk(\"Would you like to start over?\")\n                },\n                // ...\n                other: {...Endings(\"This function has not been developed\", \"#root.init.help\")\n                },\n                // ...\n                goodbye: {...Endings(\"Thank you for using Bot Chatbotterson. Goodbye.\",\"#root.init\")}\n            },\n        },            \n        // ____________\n        dm1: {\n        ...dmMachine1\n        },\n        // ____________\n        dm2: {\n        ...dmMachine2\n        },\n        // ____________\n        dm3: {\n        ...dmMachine3\n        },\n        // ____________\n        dm4: {\n        ...dmMachine4\n        },\n        asrtts: {\n            initial: 'idle',\n            states: {\n                // ...\n                idle: {\n                    on: {\n                        LISTEN: 'recognising',\n                        SPEAK: {\n                            target: 'speaking',\n                            actions: assign((_context, event) => { return { ttsAgenda: event.value } })\n                        }\n                    }\n                },\n                // ...\n                recognising: {\n\t\t            initial: 'progress',\n                    entry: 'recStart',\n                    exit: 'recStop',\n                    on: {\n                        ASRRESULT: {\n                            actions: ['recLogResult',\n                                assign((_context, event) => { return { recResult: event.value } })],\n                            target: '.match'\n                        },\n                        RECOGNISED: 'idle'\n                    },\n                    states: {\n\t\t    \t        progress: {\n\t\t\t            },\t    \t\t\t\t\t\n                        match: {\n                            entry: send('RECOGNISED'),\n                        },\n                    }\n                },\n                // ...\n                speaking: {\n                    entry: 'ttsStart',\n                    on: {\n                        ENDSPEECH: 'idle',\n                    }\n                }\n            }    \n        }\n    }\n},\n    {\n        actions: {\n            recLogResult: (context: SDSContext) => {\n                /* context.recResult = event.recResult; */\n                console.log('<< ASR: ' + context.recResult);\n            },\n            test: () => {\n                console.log('test')\n            },\n            logIntent: (context: SDSContext) => {\n                /* context.nluData = event.data */\n                console.log('<< NLU intent: ' + context.nluData.intent.name)\n            }\n        }\n    });\n\n\n\n\ninterface Props extends React.HTMLAttributes<HTMLElement> {\n    state: State<SDSContext, any, any, any>;\n}\nconst ReactiveButton = (props: Props): JSX.Element => {\n    switch (true) {\n        case props.state.matches({ asrtts: 'recognising' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"glowing 20s linear\" }} {...props}>\n                    Listening...\n                </button>\n            );\n        case props.state.matches({ asrtts: 'speaking' }):\n            return (\n                <button type=\"button\" className=\"glow-on-hover\"\n                    style={{ animation: \"bordering 1s infinite\" }} {...props}>\n                    Speaking...\n                </button>\n            );\n        default:\n            return (\n                <button type=\"button\" className=\"glow-on-hover\" {...props}>\n                    Click to start\n                </button >\n            );\n    }\n}\n\nfunction App() {\n    const { speak, cancel, speaking } = useSpeechSynthesis({\n        onEnd: () => {\n            send('ENDSPEECH');\n        },\n    });\n    const { listen, listening, stop } = useSpeechRecognition({\n        onResult: (result: any) => {\n            send({ type: \"ASRRESULT\", value: result });\n        },\n    });\n    const [current, send, service] = useMachine(machine, {\n        devTools: true,\n        actions: {\n            recStart: asEffect(() => {\n                console.log('Ready to receive a command.');\n                listen({\n                    interimResults: false,\n                    continuous: true\n                });\n            }),\n            recStop: asEffect(() => {\n                console.log('Recognition stopped.');\n                stop()\n            }),\n            ttsStart: asEffect((context, effect) => {\n                console.log('Speaking...');\n                speak({ text: context.ttsAgenda })\n            }),\n            ttsCancel: asEffect((context, effect) => {\n                console.log('TTS STOP...');\n                cancel()\n            }),\n        },\n    });\n\n\n    return (\n        <div className=\"App\">\n            <ReactiveButton state={current} onClick={() => send('CLICK')} />\n        </div>\n    )\n};\n\n\n/* RASA API\n *  */\nconst proxyurl = \"https://cors-anywhere.herokuapp.com/\";\nconst rasaurl = 'https://ap-ti-do.herokuapp.com/model/parse'\nexport const nluRequest = (text: string) =>\n    fetch(new Request(proxyurl + rasaurl, {\n        method: 'POST',\n        headers: { 'Origin': 'http://localhost:3000/' },\n        body: `{\"text\": \"${text}\"}`\n    }))\n        .then(data => data.json());\n\nconst rootElement = document.getElementById(\"root\");\nReactDOM.render(\n    <App />,\n    rootElement);\n\n\n","//\n//  srgs.js\n//  Copyright (C) 2009, Peter Ljunglöf. All rights reserved.\n//\n/*\n  This program is free software: you can redistribute it and/or modify\n  it under the terms of the GNU Lesser General Public License as published \n  by the Free Software Foundation, either version 3 of the License, or\n  (at your option) any later version.\n  \n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n  GNU General Public License for more details.\n  \n  You should have received a copy of the GNU General Public License\n  and the GNU Lesser General Public License along with this program.  \n  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n\n//////////////////////////////////////////////////////////////////////\n// encoding SRGS grammars in javascript\n\nexport function Grammar(root) {\n  this.$root = root;\n  \n  this.VOID = [OneOf([])];\n  this.NULL = [];\n  this.GARBAGE = []; \n  \n  this.$check = function() {\n    for (var i in this) {\n      if (i !== \"$root\" && i !== \"$check\") {\n\ttry {\n\t  checkSequenceExpansion(this[i]);\n\t} catch(err) {\n\t  throwRuleError(\"When checking grammar rule '\" + i + \"'\", err);\n\t}\n      }\n    }\n  }\n}\n\nexport function WordSet(str) {\n  var words = str.split(/ +/);\n  var set = {};\n  for (var i in words) {\n    set[words[i]] = true;\n  }\n  return set;\n}\n\n//////////////////////////////////////////////////////////////////////\n// rule expansion constructors\n\n// sequences are ordinary arrays\nexport function Sequence(seq) {\n  return seq;\n}\n\nexport function Ref(ref) {\n  return new RefClass(ref);\n}\n\nexport function Tag(tag) {\n  return new TagClass(tag);\n}\n\nexport function OneOf(alternatives) {\n  return new OneOfClass(alternatives);\n}\n\nexport function Repeat(min, max, sequence) {\n  return new RepeatClass(min, max, sequence);\n}\n\nexport function Optional(sequence) {\n  return new RepeatClass(0, 1, sequence);\n}\n\n//////////////////////////////////////////////////////////////////////\n// rule expansion classes\n\nexport function RefClass(ruleref) {\n  this.content = ruleref;\n  this._string = \"$\" + ruleref;\n  this.toString = function toString() {return this._string}\n}\n    \nexport function TagClass(tag) {\n  this.content = tag;\n  this._string = \"{\" + tag + \"}\";\n  this.toString = function toString() {return this._string}\n}\n\nexport function OneOfClass(alternatives) {\n  this.content = alternatives;\n  this._string = \"(\" + alternatives.join(\"|\") + \")\";\n  this.toString = function toString() {return this._string}\n}\n\nexport function RepeatClass(min, max, sequence) {\n  this.min = min;\n  this.max = max;\n  this.content = sequence;\n  this._string = this.content + \"<\" + this.min + \"-\" + (this.max==Infinity ? \"\" : this.max) + \">\"\n  this.toString = function toString() {return this._string}\n}\n\n//////////////////////////////////////////////////////////////////////\n// checking rule expansions\n\nexport function throwRuleError(message, error) {\n  if (error == undefined) {\n    throw TypeError(message);\n  } else {\n    throw TypeError(message + \"; \" + error.message);\n  }\n}\n\nexport function checkSequenceExpansion(sequence) {\n  try {\n    if (sequence.constructor !== Array) {\n      throwRuleError(\"Expected Array, found \" + sequence.constructor.name);\n    }\n    for (var i in sequence) {\n      if (sequence[i].constructor == Array) {\n\tcheckSequenceExpansion(sequence[i]);\n      } else if (sequence[i].constructor != String) {\n\tsequence[i].checkExpansion();\n      }\n    }\n  } catch(err) {\n    throwRuleError(\"When checking sequence expansion\", err);\n  }\n};\n\nRefClass.prototype.checkExpansion = function checkExpansion() {\n  if (this.content.constructor !== String) {\n    throwRuleError(\"When checking Ref content; Expected String, found \" + this.content.constructor.name);\n  }\n};\n\nTagClass.prototype.checkExpansion = function checkExpansion() {\n  if (this.content.constructor !== String) {\n      throwRuleError(\"When checking Tag content; Expected String, found \" + this.content.constructor.name);\n  }\n};\n\nOneOfClass.prototype.checkExpansion = function checkExpansion() {\n  try {\n    if (this.content.constructor !== Array) {\n      throwRuleError(\"Expected Array, found \" + this.content.constructor.name);\n    }\n    for (var i in this.content) {\n      checkSequenceExpansion(this.content[i]);\n    }\n  } catch(err) {\n    throwRuleError(\"When checking OneOf content\", err);\n  }\n};\n\nRepeatClass.prototype.checkExpansion = function checkExpansion() {\n  try {\n    if (this.min.constructor !== Number || this.max.constructor !== Number) {\n      throwRuleError(\"Expected min/max to be Number, found \" + this.min.constructor.name + \"/\" + this.max.constructor.name);\n    }\n    if (!(0 <= this.min && this.min <= this.max)) {\n      throwRuleError(\"Expected 0 <= min <= max, found \" + this.min + \"/\" + this.max);\n    }\n    checkSequenceExpansion(this.content);\n  } catch(err) {\n    throwRuleError(\"When checking Repeat content\", err);\n  }\n};\n\n"],"sourceRoot":""}